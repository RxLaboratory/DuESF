/**
	* Constructs a new DuList object
	* @class
	* @name DuList
	* @classdesc DuList helps manipulating JS Arrays and After Effects Collections the same way. It is faster than converting a Collection to an Array.<br />
	* Other specific Adobe Lists in other Applications may be supported later.<br />
	* The first item of a DuList is always at index 0, the last at index length-1.<br />
	* Accessor is the {@link DuList.at} method instead of <code>Array[]</code>.<br />
	* List length is given by the {@link DuList.length} method instead of a property.<br />
	* DuList does not reimplements methods to add or remove items, use the source list instead with the {@link DuList.list} property
	* with its original properties (from the Collection instance or Array).<br />
	* DuList can also be used as an interator with interator-like methods like {@link DuList.next}.<br />
	* You can also run a function on each item with {@link DuList.do}.
	* @param {Object} [obj] An Array or a Collection. Maybe another object; in this case a new list is constructed using the object as its first item.
	* @property {Array|Collection} list The original list, an Array or an After Effects Collection.
	* @property {int} current - The current item number
	* @property {boolean} atEnd - true if the iterator has reached the end
	* @property {boolean} atStart - true if the iterator is at the start
	* @property {boolean} valid - true if the iterator is between min and max. false until next() or previous() has been called at least once
	* @property {boolean} isCollection - true if the original list is an After Effects Collection, false otherwise
	* @property {boolean} isArray - true if the original  list is an Array, false otherwise
	*/
function DuList( obj )
{
	newList  = def( newList, [] );

	// Copy constructor
	if (obj instanceof DuList)
		newList = obj.list;

	//check if list is an Array or a Collection
	if ( DuList.isAECollection( newList ) )
	{
		this.isCollection = true;
		this.isArray = false;
	}
	else 
	{
		this.isCollection = false;
		this.isArray = true;
	}
	
	//if note a list, store it as a one-item array
	if ( !DuList.isList(newList) )
	{
		newList = [newList];
	}

	this.list = newList;

	this.current = -1;
	this.atStart = false;
	this.atEnd = false;
	this.valid = false;
}

/**
	* Returns the number of items in the list
	* @return {int} The number of items.
	*/
DuList.prototype.length = function()
{
	return this.list.length;
}

/**
 * see length
 * @alias DuList.length
 */
DuList.prototype.count = DuList.prototype.length;

/**
	* Accessor. First item is always 0, last is always length()-1<br />
	* Does not move the iterator to the index; to move the iterator use {@link DuList.goTo} instead.
	* @param {int} index The index of the item. If it is out of range (negative or > length()-1), returns null
	* @return  {object} The item at the given index.
	*/
DuList.prototype.at = function( index )
{
	var count = this.length();
	if (count == 0) return null;

	if (this.isCollection) index--;

	if (index < 0) return null;
	if (index > count-1 ) return null;

	return this.list[index];
}

/**
	* Gets the first index of a value, or -1 if not found
	* @memberof DuList
	* @param {*}	value	- The value to find. Must be compatible with the == operand if you don't provide a comparison function
	* @param {function}	[comparisonFunction]	- A function which compares two values which returns true if the values are considered the same.
	* @return {int}	The index of the value, -1 if not found
*/
DuList.prototype.indexOf = function (value, comparisonFunction)
{
	if (typeof value === 'undefined') throw "Value can not be undefined";

	var useFunction = typeof comparisonFunction !== 'undefined';

	for (var i = 0, n  = this.length(); i < n; i++)
	{
		if (!useFunction && this.at(i) == value) return i;
		else if (useFunction && comparisonFunction( this.at(i), value) ) return i;
	}
	return -1;
}

/**
	* Checks if the list has duplicated values
	* @memberof DuList
	* @return {boolean}	true if the list has duplicated values. Always false for Ae Collections as they can't have duplicated items.
*/
DuList.prototype.hasDuplicates = function ()
{
	for (var i = 0, n = this.length(); i < n; i++) {
		for (var j = i+1; j < n; j++ ) {
			if ( this.at(i) === this.at(j) ) return true;
		}
	}
	return false;
}

/**
	* Returns all duplicated values found in the list
	* @memberof DuList
	* @return {DuList}	The duplicated values. An empty list for Ae Collections as they can't have duplicated items.
*/
DuList.prototype.getDuplicates = function ()
{
	if (this.isAECollection) return new DuList();

	var duplicates = [];

	for (var i = 0, n = this.length(); i < n; i++) {
		for (var j = i+1; j < n; j++) {
			if ( this.at(i) === this.at(j) ) duplicates.push( this.at(j) );
		}
	}

	duplicates = new DuList( duplicates );
	duplicates.removeDuplicates( duplicates );

	return duplicates;
}

/**
	* Removes all duplicated values from the list, and returns them
	* @memberof DuList
	* @param {function}	[comparisonFunction] - A function which compares two values which returns true if the values are considered the same.
	* @return {Array}	The duplicated (and removed) values. An empty list for Ae Collections as they can't have duplicated items.
*/
DuList.prototype.removeDuplicates = function ( comparisonFunction )
{
	if (this.isAECollection) return new DuList();

	var useFunction = typeof comparisonFunction !== 'undefined';
	var removed = [];

	for ( var i = 0, n = this.length(); i < n; i++ )
	{
        for (var j = i+1; j < n; j++)
		{
            if ( !useFunction && this.at(i) === this.at(j) ) removed = removed.concat( this.list.splice(j,1) );
			else if ( useFunction && comparisonFunction( this.at(i), this.at(j) ) ) removed = removed.concat( this.list.splice(j,1) );
        }
	}

	//sometimes the two last items may still be the same (for a reason I don't understand)
	if (this.length > 1)
	{
		var last = this.last();
		var ante = this.at( this.length -2 );
		if ( !useFunction && last === ante) removed.push( this.list.pop() );
		if (useFunction && comparisonFunction( ante, last ) ) removed.push( this.list.pop() );
	}
	
	return new DuList( removed );
}

/**
	* Compares two arrays.<br />
	* The items in the arrays must be compatible with the == operand if you don't provide a comparison function
	* @memberof DuList
	* @param {Array|Collection|DuList} other - The other list
	* @param {int} [floatPrecision=-1] - The precision for (float) number comparison, number of decimals. Set to -1 to not use.
	* @return {boolean} true if the two arrays contain the same values
*/
DuList.prototype.equals = function ( other, comparisonFunction, floatPrecision )
{
	var useFunction = typeof comparisonFunction !== 'undefined';

	if ( !DuList.isList(other) ) return false;

	other = new DuList( other );

	if ( this.length() != other.length() ) return false;

	var originalIndex = this.current;

	DuList.reinitIterator();
	var ok = true;
	while( var item1 = DuList.next() )
	{
		var item2 = other.at( this.current );

		// A list, recursive
		if ( DuList.isList( item1 ) )
		{
			var test = new DuList( item1 );
			if ( !test.equals( item2, comparisonFunction, floatPrecision ) ) ok = false;
			continue;
		}

		// Comparison function
		if (useFunction)
		{
			if ( !comparisonFunction( item1, item2 ) ) ok = false;
			continue;
		}

		// Numbers
		if ( jstype( item1 ) == 'number' )
		{
			if ( !DuMath.equals( item1, item2, floatPrecision) ) ok = false;
			continue;
		}

		// Other
		if (item1 != item2) ok = false;
	}

	// Restore original iterator index
	this.goTo( originalIndex );
	return ok;
}

/**
	* Returns true if the list is empty
	* @return {boolean}
	*/
DuList.prototype.isEmpty = function()
{
	return this.length() == 0;
}

/**
	* Gets the last item in the list
	* @return {*} The last item, null if the list is empty.
	*/
DuList.prototype.last = function()
{
	if ( this.isEmpty() ) return null;
	return this.at( this.length() - 1 );
}

/**
	* Gets the first item in the list
	* @return {*} The first item, null if the list is empty.
	*/
DuList.prototype.first = function()
{
	if ( this.isEmpty() ) return null;
	return this.at( 0 );
}

// ================ ITERATOR METHODS ================


/**
	* Reinits the iterator, i.e. go to index -1 so that the next call to {@link DuList.next} returns the first item.
*/
DuList.prototype.reinitIterator = function ( )
{
	this.goTo(-1);
}

/**
	* Sets the iterator on the index
	* @param {int} index - The index
	* @return {*} The item at index, or null if the index is invalid
*/
DuList.prototype.goTo = function(index)
{
	this.current = index;

	var count = this.length();

	if ( this.current < 0 || this.current >= count ) this.valid = false;
	else this.valid = true;

	if ( this.current == 0 ) this.atStart = true;
	else this.atStart = false;

	if ( this.current == count-1 ) this.atEnd = true;
	else this.atEnd = false;

	if (this.valid) return this.at( this.current );
	else return null;
}

/**
	* Goes to the end of the Iterator
	* @return {Object} The item at the end, or null if length is 0
*/
DuList.prototype.goToEnd = function ()
{
	if ( this.isEmpty() ) return null;
	return this.goTo( this.length() - 1 );
}

/**
	* Goes to the start of the Iterator
	* @return {Object} The item at the start, or null if length is 0
*/
DuList.prototype.goToStart = function ()
{
	if ( this.isEmpty() ) return null;
	return this.goTo( 0 );
}

/**
	* Increments the Iterator<br />
	* Must be called at least once to validate the iterator
	* @return {Object} The next item, or null if there isn't
*/
DuList.prototype.next = function ()
{
	if ( this.isEmpty() ) return null;

	if ( !this.valid )
	{
		return this.goToStart();
	}

	if ( this.current < this.length()-1 )
	{
		return this.goTo( this.current + 1 );
	}

	return null;
}

/**
	* Decrements the Iterator
	* if it's called while valid is false, goes to the end
	* @return {Object} The previous item, or null if there isn't
*/
DuList.prototype.previous = function ()
{
	if ( this.isEmpty() ) return null;

	if (!this.valid)
	{
		return this.goToEnd();
	}

	if (this.current > 0)
	{
		return this.goTo( this.current - 1 );
	}

	return null;
}

/**
	* Executes a function on each item of the List
	* @param {function} callBack - The function to execute, which takes one parameter: an item of the list
*/
DuList.prototype.do = function (callBack)
{
	if ( this.isEmpty() ) return;

	// Keep the current index
	var current = this.current;

	for (var i = 0, n = this.length() ; i < n ; i++)
	{
		this.valid = true;
		this.current = i;
		callBack( this.at(i) );
	}

	// Restore the current index
	this.goTo(current);
}


// ================ STATIC ==========================

/**
	* Checks if the object is an AE collection
	* @static
	* @param {Object} collection - The object to check
	* @return {boolean} true if collection is a collection, false if it's an array or any other object
*/
DuList.isAECollection = function (collection)
{
	return collection instanceof ItemCollection || collection instanceof LayerCollection || collection instanceof OMCollection || collection instanceof RQItemCollection;
}

/**
	* Checks if this is an Array or an After Effects collection type or a {@link DuList}
	* @static
	* @param {Array|Collection} list - The list to check
	* @return {boolean} true if this is a Cllection or an Array or a {@link DuList}
*/
DuList.isList = function (list)
{
	return (list instanceof Array || DuList.isAECollection(list) || list instanceof DuList);
}

// ================ DEPRECATED ======================


/**
	* A function to compare two elements in an array
	* @callback DuList.indexOf~comparisonFunction
	* @memberof DuList.indexOf
	* @param {*} elementInArray The element in the array
	* @param {*} value The value to compare
	* @return {bool} true if the two values should be considered the same
*/

/**
	* Gets the first index of a value in an Array, or -1 if not found
	* @memberof DuList
	* @static
	* @deprecated
	* @param {Array}	arr	- The array
	* @param {*}	value	- The value to find. Must be compatible with the == operand, or provide a comparison function
	* @param {function}	[comparisonFunction]	- A function which compares two values which returns true if the values are considered the same.
	* @return {int}	The index of the value, -1 if not found
*/
DuList.indexOf = function (arr,value,comparisonFunction)
{
	if (value == undefined) throw "Value can not be undefined";
	var useFunction = typeof comparisonFunction === 'function';

	for (var i = 0;i<arr.length;i++)
	{
		if (!useFunction && arr[i] == value) return i;
		if (useFunction && comparisonFunction(arr[i],value)) return i;
	}
	return -1;
}

/**
	* Checks if the array has duplicate values
	* @memberof DuList
	* @static
	* @deprecated
	* @param {Array}	arr	- The array
	* @return {boolean}	true if the array has duplicate values
*/
DuList.hasDuplicates = function (arr)
{
	for (var i = 0;i<arr.length-1;i++) {
		for (var j=i+1;j<arr.length;j++) {
			if (arr[i] === arr[j]) return true;
		}
	}
	return false;
}

/**
	* Returns all duplicated values found in the array
	* @memberof DuList
	* @static
	* @deprecated
	* @param {Array}	arr	- The array
	* @return {Array}	The duplicated values
*/
DuList.getDuplicates = function (arr)
{
	var duplicates = [];
	for (var i = 0;i<arr.length-1;i++) {
	for (var j=i+1;j<arr.length;j++) {
	if (arr[i] === arr[j]) duplicates.push(arr[j]);
	}
	}
	DuList.removeDuplicates(duplicates);
	return duplicates;
}

/**
	* Removes all duplicated values from the Array, and returns them
	* @memberof DuList
	* @static
	* @deprecated
	* @param {Array}	arr	- The array
	* @param {function}	[comparisonFunction] - A function which compares two values which returns true if the values are considered the same.
	* @return {Array}	The duplicated (and removed) values
*/
DuList.removeDuplicates = function (arr, comparisonFunction)
{
	var useFunction = typeof comparisonFunction === 'function';
	var removed = [];
	for (var i = 0;i<arr.length-1;i++)
	{
        for (var j=i+1;j<arr.length;j++)
		{
            if (! useFunction && arr[i] === arr[j]) removed = removed.concat(arr.splice(j,1));
			if (useFunction && comparisonFunction(arr[i],arr[j]) ) removed = removed.concat(arr.splice(j,1));
        }
	}
	//sometimes the two last items may still be the same (for a reason I don't understand)
	if (! useFunction && arr[arr.length-2] === arr[arr.length-1]) removed.push(arr.pop());
	if (useFunction && comparisonFunction(arr.length-2,arr.length-1) ) removed.push(arr.pop());

	return removed;
}

/**
	* Compares two arrays.<br />
	* The items in the arrays must be compatible with the == operand
	* @memberof DuList
	* @static
	* @deprecated
	* @param {Array|Collection} array1 - The array
	* @param {Array|Collection} array2 - The array
	* @param {int} [floatPrecision=-1] - The precision for (float) number comparison, number of decimals. Set to -1 to not use.
	* @return {boolean} true if the two arrays contain the same values
*/
DuList.compare = function (array1,array2,floatPrecision)
{
	if (!DuList.isList(array1) && !DuList.isList(array2))
	{
		if (typeof array1 == 'number' && typeof array2 == 'number')
		{
			return DuMath.equals(array1,array2,floatPrecision)
		}
		else return array1 == array2;
	}
	if (DuList.isList(array1) && !DuList.isList(array2)) return false;
	if (!DuList.isList(array1) && DuList.isList(array2)) return false;
	if (array1.length != array2.length) return false;

	var it = new DuList(array1);
	var ok = true;
	it.do(function (item1)
	{
		var item2 = array2[it.current];
		if (!DuList.compare(item1,item2,floatPrecision))
		{
			ok = false;
			return;
		}
	});

	return ok;
}
