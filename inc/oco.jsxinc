/**
 * Methods to load and create OCO Documents and armatures
 * @namespace
 */
var DuOCO = {};

/**
 * Types of OCO armatures
 * @enum {string}
 */
DuOCO.Type = {
    /**
     * A meta-rig, used to automatically create a default armature to be used with an auto-rig.
     */
    META: 'meta',
    /**
     * An actual (rigged) character.
     */
    CHARACTER: 'character'
}

/**
 * Predefined limbs
 * @enum {string}
 */
DuOCO.Limb = {
    SPINE: 'spine',
    ARM: 'arm',
    LEG: 'leg',
    TAIL: 'tail',
    WING: 'wing',
    HAIR: 'hair',
    SNAKE_SPINE: 'snakeSpine',
    FIN: 'fin',
    CUSTOM: 'custom'
}

/**
 * Some bone identifierss
 * @enum {string}
 */
DuOCO.Bone = {
    CUSTOM: 'custom',
    TIP: 'tip',
    CLAVICLE: 'clavicle',
    HUMERUS: 'humerus',
    RADIUS: 'radius',
    CARPUS: 'carpus',
    FINGER: 'finger',
    HEEL: 'heel',
    FEMUR: 'femur',
    TIBIA: 'tibia',
    TARSUS: 'tarsus',
    TOE: 'toe',
    HIPS: 'hips',
    SPINE: 'spine',
    NECK: 'neck',
    HEAD: 'head',
    SKULL: 'skull',
    TAIL_ROOT: 'tail1',
    TAIL_MID: 'tail2',
    TAIL_END: 'tail3',
    FEATHER: 'feather',
    SNAKE_SPINE_ROOT: 'snakeSpine1',
    SNAKE_SPINE_MID: 'snakeSpine2',
    SNAKE_SPINE_END: 'snakeSpine3',
    HAIR_ROOT: 'snakeSpine1',
    HAIR_MID: 'snakeSpine2',
    HAIR_END: 'snakeSpine3',
    FIN: 'fin',
    FIN_FISHBONE: 'finBone'
}

/**
 * Types of limbs
 * @enum {string}
 */
DuOCO.LimbType = {
    HOMINOID: 'hominoid',
    PLANTIGRADE: 'plantigrade',
    DIGITIGRADE: 'digitigrade',
    UNGULATE: 'ungulate',
    ARTHROPOD: 'arthropod',
    CUSTOM: 'custom'
}

/**
 * Sides for the limbs Use these with {@link DuOCO.Location} to differenciate similar limbs,<br />
 * for example, a leg can be Front-Right, Front-Left, Back-Right, Back-Left, etc.
 * @enum {string}
 */
DuOCO.Side = {
    LEFT: DuScriptUI.String.LEFT_SHORT,
    RIGHT: DuScriptUI.String.RIGHT_SHORT,
    NONE: ''
}

/**
 * Locations for the limbs. Use these with {@link DuOCO.Side} to differenciate similar limbs,<br />
 * for example, a leg can be Front-Right, Front-Left, Back-Right, Back-Left, etc.
 * @enum {string}
 */
DuOCO.Location = {
    FRONT: DuScriptUI.String.FRONT_SHORT,
    BACK: DuScriptUI.String.BACK_LOCATION_SHORT,
    TAIL: DuScriptUI.String.TAIL_SHORT,
    MIDDLE: DuScriptUI.String.MIDDLE_SHORT,
    ABOVE: DuScriptUI.String.ABOVE_SHORT,
    UNDER: DuScriptUI.String.UNDER_SHORT,
    NONE: ''
}

DuOCO.View = {
    FRONT: 0,
    LEFT: 1,
    RIGHT: 2,
    BACK: 3,
    TOP: 4,
    BOTTOM: 5
}

/**
 * Gets the boundaries of an armature (a chain of bones)
 * @param {DuOCOBone[]} armature The chain of bones
 * @returns {float[]} [left, top, right, bottom]
 */
DuOCO.getBounds = function ( armature )
{
    var left = 9999;
    var right = -9999;
    var top = 9999;
    var bottom = -9999;

    for (var i = 0, n = armature.length; i < n; i++)
    {
        var b = armature[i];
        // Check current bone
        if (b.x < left) left = b.x;
        if (b.x > right) right = b.x;
        if (b.y < bottom) bottom = b.y;
        if (b.y > top) top = b.y;
        // Check children
        var childBounds = DuOCO.getBounds( b.children );
        if (childBounds[0] < left) left = childBounds[0];
        if (childBounds[1] < top) top = childBounds[1];
        if (childBounds[2] < right) right = childBounds[2];
        if (childBounds[3] < bottom) bottom = childBounds[3];
        // Check other limbs
        for ( var j = 0, nL = b.limbs.length; j < nL; j++ )
        {
            var limbBounds = b.limbs[i].bounds();
            if (limbBounds[0] < left) left = limbBounds[0];
            if (limbBounds[1] < top) top = limbBounds[1];
            if (limbBounds[2] < right) right = limbBounds[2];
            if (limbBounds[3] < bottom) bottom = limbBounds[3];
        }
    }

    return [left, top, right, bottom];
}

/**
 * Creates a new OCO Document.
 * @class
 * @classdesc An Open Cut-Out character or meta-rig document.
 * @param {string} name The name of the character or the meta rig
 */
function DuOCODoc(name)
{
    /**
     * The type of this OCO Doc
     * @name type
     * @memberof DuOCODoc
     * @type {string}
     */
    this.type = DuOCO.Type.META;
    /**
     * The name of this OCO Doc
     * @name name
     * @memberof DuOCODoc
     * @type {string}
     */
    this.name = name;
    /**
     * The height of the character. Should always be 1!
     * @name height
     * @memberof DuOCODoc
     * @type {float}
     */
    this.height = 185.0;
    /**
     * The width of the character.
     * @name width
     * @memberof DuOCODoc
     * @type {float}
     */
    this.width = 60.0,
    /**
     * The coordinates of the center of mass of the character. [X, Y].
     * @name centerOfMass
     * @memberof DuOCODoc
     * @type {float[]}
     */
    this.centerOfMass = [0.0, 107.0];
    /**
     * The limbs/ Armatures
     * @name limbs
     * @memberof DuOCOLimb
     * @type {DuOCOLimb[]}
     */
    this.limbs = [];
    this.resolution = [1920,1080];
    this.world = [960,980];
    this.pixelsPerCm = 4.22;
}

/**
 * Gets the boundaries of the doc
 * @returns {float[]} [left, top, right, bottom]
 */
DuOCODoc.prototype.bounds = function ()
{
    var left = 9999;
    var right = -9999;
    var top = 9999;
    var bottom = -9999;

    for (var i = 0, n = this.limbs.length; i < n; i++)
    {
        var limbBounds = this.limbs[i].bounds();
        if (limbBounds[0] < left) left = limbBounds[0];
        if (limbBounds[1] < top) top = limbBounds[1];
        if (limbBounds[2] < right) right = limbBounds[2];
        if (limbBounds[3] < bottom) bottom = limbBounds[3];
    }

    return [left, top, right, bottom];
}

/**
 * Updates the width and height of the character, according to the content.<br />
 * This method should be called each time a limb/bone is added/removed/edited and the bounds may change.
 */
DuOCODoc.prototype.updateSize = function()
{
    // Update doc width & height
    var bounds = this.bounds();
    // right - left
    this.width = this.bounds[2] - this.bounds[0];
    // top - bottom
    this.height = this.bounds[1] - this.bounds[3];
}

/**
 * Creates a new limb and adds it to the doc
 * @param {DuOCO.Limb} [limb=DuOCO.Limb.CUSTOM] A Predefined limb
 * @param {DuOCO.Side} [side=DuOCO.Side.NONE] - The side of the limb
 * @param {DuOCO.Location} [location=DuOCO.Location.NONE] - The location of the limb
 * @param {DuOCO.LimbType} [type=DuOCO.LimbType.CUSTOM] - The type of the limb
 * @return {DuOCOLimb} The new limb
 */
DuOCODoc.prototype.newLimb = function( limb, side, location, type )
{
    var l = new DuOCOLimb( limb, side, location, type );
    this.limbs.push(l);
    return l;
}

/**
 * Creates a new arm.
 * @param {DuOCO.LimbType} [type=DuOCO.LimbType.PLANTIGRADE] The type of limb
 * @param {DuOCO.Side} [side=DuOCO.Side.LEFT] The side
 * @param {Boolean} [shoulder=false] Whether to create a shoulder
 * @param {Boolean} [arm=true]  Whether to create an arm / humerus
 * @param {Boolean} [forearm=true]  Whether to create a forearm
 * @param {Boolean} [hand=true]  Whether to create a hand
 * @param {Boolean} [claws=false]  Whether to add claws
 * @param {float[]} [position] The position of the first bone of the arm.<br />
 * If omitted, computed automatically according to the current character in the doc.
 * @param {DuOCO.Location} [location=DuOCO.Location.FRONT] The location of the limb
 * @param {DuOCO.View} [view] The view
 * @returns {DuOCOLimb} The arm
 */
DuOCODoc.prototype.newArm = function( type, side, shoulder, arm, forearm, hand, claws, position, location, view )
{
    side = def(side, DuOCO.Side.LEFT);
    type = def(type, DuOCO.LimbType.PLANTIGRADE);
    location = def(location, DuOCO.Location.FRONT);

    shoulder = def( shoulder, false );
    arm = def( arm, true );
    forearm = def( forearm, true );
    hand = def( hand, true );
    claws = def( claws, false );

    // Unit
    var u = this.height;

    // type
    var hum = type == DuOCO.LimbType.PLANTIGRADE && !claws;
    var plan = type == DuOCO.LimbType.PLANTIGRADE && claws;
    var dig = type == DuOCO.LimbType.DIGITIGRADE;
    var ung = type == DuOCO.LimbType.UNGULATE;
    var artF = type == DuOCO.LimbType.ARTHROPOD && location != DuOCO.Location.MIDDLE && location != DuOCO.Location.BACK;
    var artM = type == DuOCO.LimbType.ARTHROPOD && location == DuOCO.Location.MIDDLE;
    var artB = type == DuOCO.LimbType.ARTHROPOD && location == DuOCO.Location.BACK;
    if ( !hum && !plan && !dig && !ung && !artF && !artM && !artB ) hum = true;

    // View
    if (typeof view === 'undefined')
    {
        if (type == DuOCO.LimbType.PLANTIGRADE && !claws) view = DuOCO.View.FRONT;
        else view = DuOCO.View.RIGHT;
    }

    // count how many bones we need
    var num = 1;
    if ( shoulder ) num++;
    if ( arm ) num++;
    if ( forearm ) num++;
    if ( hand ) num++;
    if ( claws ) num++;

    if (num == 1) return null;

    // Create limb
    var limb = this.newLimb( DuOCO.Limb.ARM, side, location, type );
    var b = limb.newArmature( DuScriptUI.String.ARM, num );

    // side
    var s = 1;
    if ( side == DuOCO.Side.RIGHT && view == DuOCO.View.FRONT ) s = -1;
    else if ( side == DuOCO.Side.LEFT && view == DuOCO.View.BACK ) s = -1;
    else if ( view == DuOCO.View.LEFT ) s = -1;  

    // shoulder position
    var x, y;
    var ox = 0;
    var oy = 0;
    if (hum)
    {
        x = s * u * .02;
        y = u * .78;
    }
    else if (plan)
    {
        x = s * u * .40;
        y = u * .92;
    }
    else if (dig)
    {
        x = s * u * .45;
        y = u * .86;
    }
    else if (ung)
    {
        x = s * u * .33;
        y = u * .80;
    }
    else if (artF)
    {
        x = s * u * .33;
        y = u * .65;
    }
    else if (artM)
    {
        x = s * u * .09;
        y = u * .50;
    }
    else if (artB)
    {
        x = s * u * -.03;
        y = u * .48;
    }

    // offset
    if (typeof position !== 'undefined' )
    {
        ox = position[0] - x;
        oy = position[1] - y;
    }

    // for each part, set the location
    if ( shoulder )
    {
        b.name = DuScriptUI.String.SHOULDER;
        b.type = DuOCO.Bone.CLAVICLE;
        b.x = x + ox;
        b.y = y + oy;
        if (b.children.length > 0) b = b.children[0];
    }
    if ( arm )
    {
        b.name = DuScriptUI.String.ARM;
        b.type = DuOCO.Bone.HUMERUS;
        if (hum)
        {
            b.x = s * u * .12 + ox;
            b.y = u * .77 + oy;
        }
        else if (plan)
        {
            b.x = s * u * .48 + ox;
            b.y = u*.74 + oy;
        }
        else if (dig)
        {
            b.x = s * u * .45 + ox;
            b.y = u*.66 + oy;
        }
        else if (ung)
        {
            b.x = s * u * .35 + ox;
            b.y = u*.63 + oy;
        }
        else if (artF)
        {
            b.x = s * u * .24 + ox;
            b.y = u*.45 + oy;
        }
        else if (artM)
        {
            b.x = s * u * -.01 + ox;
            b.y = u*.44 + oy;
        }
        else if (artB)
        {
            b.x = s * u * -.17 + ox;
            b.y = u*.43 + oy;
        }
        if (b.children.length > 0) b = b.children[0];
    }
    if ( forearm )
    {
        b.name = DuScriptUI.String.FOREARM;
        b.type = DuOCO.Bone.RADIUS;
        if (hum)
        {
            b.x = s * u * .15 + ox;
            b.y = u *.65 + oy;
        }
        else if (plan)
        {
            b.x = s * u * .36 + ox;
            b.y = u*.44 + oy;
        }
        else if (dig)
        {
            b.x = s * u * .21 + ox;
            b.y = u*.45 + oy;
        }
        else if (ung)
        {
            b.x = s * u * .24 + ox;
            b.y = u*.53 + oy;
        }
        else if (artF)
        {
            b.x = s * u * .55 + ox;
            b.y = u*.80 + oy;
        }
        else if (artM)
        {
            b.x = s * u * -.08 + ox;
            b.y = u*.82 + oy;
        }
        else if (artB)
        {
            b.x = s * u * -.44 + ox;
            b.y = u*.92 + oy;
        }
        if (b.children.length > 0) b = b.children[0];
    }
    if ( hand )
    {
        b.name = DuScriptUI.String.HAND;
        b.type = DuOCO.Bone.CARPUS;
        if (hum)
        {
            b.x = s * u * .12 + ox;
            b.y = u * .51 + oy;
        }
        else if (plan)
        {
            b.x = s * u * .38 + ox;
            b.y = u*.05 + oy;
        }
        else if (dig)
        {
            b.x = s * u * .45 + ox;
            b.y = u*.14 + oy;
        }
        else if (ung)
        {
            b.x = s * u * .19 + ox;
            b.y = u*.31 + oy;
        }
        else if (artF)
        {
            b.x = s * u * .77 + ox;
            b.y = u*.28 + oy;
        }
        else if (artM)
        {
            b.x = s * u * -.17 + ox;
            b.y = u*.42 + oy;
        }
        else if (artB)
        {
            b.x = s * u * -.77 + ox;
            b.y = u*.47 + oy;
        }
        if (b.children.length > 0) b = b.children[0];
    }
    if ( claws )
    {
        b.name = DuScriptUI.String.CLAWS;
        b.type = DuOCO.Bone.FINGER;
        if (plan)
        {
            b.x = s * u * .455 + ox;
            b.y = u*.035 + oy;
        }
        else if (dig)
        {
            b.x = s * u * .49 + ox;
            b.y = u*.03 + oy;
        }
        else if (ung)
        {
            b.x = s * u * .19 + ox;
            b.y = u*.14 + oy;
        }
        else if (artF)
        {
            b.x = s * u * .86 + ox;
            b.y = u*.07 + oy;
        }
        else if (artM)
        {
            b.x = s * u * -.25 + ox;
            b.y = u*.07 + oy;
        }
        else if (artB)
        {
            b.x = s * u * -.98 + ox;
            b.y = u*.07 + oy;
        }
        if (b.children.length > 0) b = b.children[0];
    }
    // Tip
    b.name = DuScriptUI.String.ARM + '_' + DuScriptUI.String.TIP_BONE;
    b.type = DuOCO.Bone.TIP;
    if (hum)
    {
        b.x = s * u * .08 + ox;
        b.y = u * .42 + oy;
    }
    else if (plan)
    {
        b.x = s * u * .585 + ox;
        b.y = 0 + oy;
    }
    else if (dig)
    {
        b.x = s * u * .59 + ox;
        b.y = u*.03 + oy;
    }
    else if (ung)
    {
        b.x = s * u * .21 + ox;
        b.y = oy;
    }
    else if (artF)
    {
        b.x = s * u * .93 + ox;
        b.y = oy;
    }
    else if (artM)
    {
        b.x = s * u * -.31 + ox;
        b.y = oy;
    }
    else if (artB)
    {
        b.x = s * u * -1.06 + ox;
        b.y = oy;
    }

    //Heel
    if (plan)
    {
        var heelBone = new DuOCOBone( DuScriptUI.String.HEEL );
        heelBone.type = DuOCO.Bone.HEEL;
        heelBone.x = s * u * .38 + ox;
        heelBone.y = 0 + oy;
        b.children.push(heelBone);
    }

    return limb;
}

/**
 * Creates a new leg.
 * @param {DuOCO.LimbType} [type=DuOCO.LimbType.PLANTIGRADE] The type of limb
 * @param {DuOCO.Side} [side=DuOCO.Side.LEFT] The side
 * @param {Boolean} [thigh=true]  Whether to create a thigh
 * @param {Boolean} [calf=true]  Whether to create a calf
 * @param {Boolean} [foot=true]  Whether to create a foot
 * @param {Boolean} [claws=false]  Whether to add claws
 * @param {float[]} [position] The position of the first bone of the arm.<br />
 * If omitted, computed automatically according to the current character in the doc.
 * @param {DuOCO.Location} [location=DuOCO.Location.BACK] The location of the limb
 * @param {DuOCO.View} [view] The view
 * @returns {DuOCOLimb} The leg
 */
DuOCODoc.prototype.newLeg = function( type, side, thigh, calf, foot, claws, position, location, view )
{
    side = def(side, DuOCO.Side.LEFT);
    type = def(type, DuOCO.LimbType.PLANTIGRADE);
    location = def(location, DuOCO.Location.BACK);

    thigh = def( thigh, true );
    calf = def( calf, true );
    foot = def( foot, true );
    claws = def( claws, false );

    // Unit
    var u = this.height;

    // type
    var plan = type == DuOCO.LimbType.PLANTIGRADE;
    var dig = type == DuOCO.LimbType.DIGITIGRADE;
    var ung = type == DuOCO.LimbType.UNGULATE;
    if ( !plan && !dig && !ung ) hum = true;

    // View
    if (typeof view === 'undefined')
    {
        if (type == DuOCO.LimbType.PLANTIGRADE) view = DuOCO.View.FRONT;
        else view = DuOCO.View.RIGHT;
    }

    // count how many bones we need
    var num = 1;
    if ( thigh ) num++;
    if ( calf ) num++;
    if ( foot ) num++;
    if ( claws ) num++;

    if (num == 1) return null;

    // Create limb
    var limb = this.newLimb( DuOCO.Limb.LEG, side, location, type );
    var b = limb.newArmature( DuScriptUI.String.LEG, num );

    // side
    var s = 1;

    if ( side == DuOCO.Side.RIGHT && view == DuOCO.View.FRONT ) s = -1;
    else if ( side == DuOCO.Side.LEFT && view == DuOCO.View.BACK ) s = -1;
    else if ( view == DuOCO.View.LEFT ) s = -1;

    // thigh position
    var x, y;
    var ox = 0;
    var oy = 0;
    if (plan)
    {
        x = s * u * .04;
        y = u * .53;
    }
    else if (dig)
    {
        x = s * u * -.45;
        y = u * .73;
    }
    else if (ung)
    {
        x = s * u * -.26;
        y = u * .69;
    }

    // offset
    if (typeof position !== 'undefined' )
    {
        ox = position[0] - x;
        oy = position[1] - y;
    }

    // for each part, set the location
    if ( thigh )
    {
        b.name = DuScriptUI.String.THIGH;
        b.type = DuOCO.Bone.FEMUR;
        b.x = x + ox;
        b.y = y + oy;
        if (b.children.length > 0) b = b.children[0];
    }
    if ( calf )
    {
        b.name = DuScriptUI.String.CALF;
        b.type = DuOCO.Bone.TIBIA;
        if (plan)
        {
            b.x = s * u * .05 + ox;
            b.y = u*.28 + oy;
        }
        else if (dig)
        {
            b.x = s * u * -.16 + ox;
            b.y = u*.54 + oy;
        }
        else if (ung)
        {
            b.x = s * u * -.2 + ox;
            b.y = u*.52 + oy;
        }
        if (b.children.length > 0) b = b.children[0];
    }
    if ( foot )
    {
        b.name = DuScriptUI.String.FOOT;
        b.type = DuOCO.Bone.TARSUS;
        if (plan)
        {
            b.x = s * u * .036 + ox;
            b.y = u*.027 + oy;
        }
        else if (dig)
        {
            b.x = s * u * -.5 + ox;
            b.y = u*.24 + oy;
        }
        else if (ung)
        {
            b.x = s * u * -.38 + ox;
            b.y = u*.33 + oy;
        }
        if (b.children.length > 0) b = b.children[0];
    }
    if ( claws )
    {
        b.name = DuScriptUI.String.CLAWS;
        b.type = DuOCO.Bone.TOE;
        if (plan)
        {
            b.x = s * u * .10 + ox;
            b.y = u*.0125 + oy;
        }
        else if (dig)
        {
            b.x = s * u * -.37 + ox;
            b.y = u*.03 + oy;
        }
        else if (ung)
        {
            b.x = s * u * -.37 + ox;
            b.y = u*.08 + oy;
        }
        if (b.children.length > 0) b = b.children[0];
    }
    // Tip
    b.name = DuScriptUI.String.ARM + '_' + DuScriptUI.String.TIP_BONE;
    b.type = DuOCO.Bone.TIP;
    if (plan)
    {
        b.x = s * u * .145 + ox;
        b.y = oy;
    }
    else if (dig)
    {
        b.x = s * u * -.25 + ox;
        b.y = oy;
    }
    else if (ung)
    {
        b.x = s * u * -.34 + ox;
        b.y = oy;
    }

    //Heel
    if (plan && claws)
    {
        var heelBone = new DuOCOBone( DuScriptUI.String.HEEL );
        heelBone.type = DuOCO.Bone.HEEL;
        heelBone.x = s * u * .01 + ox;
        heelBone.y = oy;
        b.children.push(heelBone);
    }

    return limb;
}

/**
 * Creates a new spine.
 * @param {Boolean} [head=true]  Whether to create a head
 * @param {int} [neck=1] Number of neck bones
 * @param {int} [spine=2] Number of spine bones
 * @param {Boolean} [hips=true]  Whether to create hips
 * @param {float[]} [position] The position of the first bone of the arm.<br />
 * If omitted, computed automatically according to the current character in the doc.
 * @param {DuOCO.View} [view] The view
 * @returns {DuOCOLimb} The spine
 */
DuOCODoc.prototype.newSpine = function( head, neck, spine, hips, position )
{
    head = def( head, true );
    neck = def( neck, 1 );
    spine = def( spine, 2 );
    hips = def( hips, false );

    // Unit
    var u = this.height;

    // count how many bones we need
    var num = 1;
    if ( head ) num++;
    num += neck;
    num += spine;
    if ( hips ) num++;

    if (num == 1) return null;

    // Create limb
    var limb = this.newLimb( DuOCO.Limb.SPINE, DuOCO.Side.NONE, DuOCO.Location.NONE );
    var b = limb.newArmature( DuScriptUI.String.SPINE, num );

    // hips position
    var ox = 0;
    var oy = 0;
    var x = 0;
    var y = u * .53;

    // offset
    if (typeof position !== 'undefined' )
    {
        ox = position[0] - x;
        oy = position[1] - y;
    }

    // for each part, set the location
    if ( hips )
    {
        b.name = DuScriptUI.String.HIPS;
        b.type = DuOCO.Bone.HIPS;
        b.x = x + ox;
        b.y = y + oy;
        if (b.children.length > 0) b = b.children[0];
    }
    if (spine > 0)
    {
        var spineLength = u*.27 / spine;
        var spineStart = u*.56;
        for (var i = 0; i < spine; i++)
        {
            b.name = DuScriptUI.String.SPINE;
            b.type = DuOCO.Bone.SPINE;
            b.y = spineStart + i*spineLength + oy;
            b.x = ox;
            if (b.children.length > 0) b = b.children[0];
        }
    }
    if (neck > 0)
    {
        var neckLength = u*.06 / neck;
        var neckStart = u*.83;
        for (var i = 0; i < neck; i++)
        {
            b.name = DuScriptUI.String.NECK;
            b.type = DuOCO.Bone.NECK;
            b.y = neckStart + i*neckLength + oy;
            b.x = ox;
            if (b.children.length > 0) b = b.children[0];
        }
    }  
    if ( head )
    {
        b.name = DuScriptUI.String.HEAD;
        b.type = DuOCO.Bone.SKULL;
        b.x = ox;
        b.y = u*.89 + oy;
        if (b.children.length > 0) b = b.children[0];
    }

    // Tip
    b.name = DuScriptUI.String.SPINE + '_' + DuScriptUI.String.TIP_BONE;
    b.type = DuOCO.Bone.TIP;
    b.x = ox;
    b.y = u + oy;

    return limb;
}

/**
 * Creates a new tail.
 * @param {int} [numBones=3] Number of tail bones
 * @returns {DuOCOLimb} The spine
 */
DuOCODoc.prototype.newTail = function( numBones )
{
    numBones = def( numBones, 3 );

    // Unit
    var u = this.height;

    // count how many bones we need
    var num = numBones+1;

    if (num == 1) return null;

    // Create limb
    var limb = this.newLimb( DuOCO.Limb.TAIL, DuOCO.Side.NONE, DuOCO.Location.NONE );
    var b = limb.newArmature( DuScriptUI.String.TAIL, num );

    // for each part, adjust name and type
    for (var i = 0, n = num-1; i < n; i++)
    {
        b.name = DuScriptUI.String.TAIL;
        if ( i <= (n-1) / 3) b.type = DuOCO.Bone.TAIL_ROOT;
        else if ( i <= (n-1)*2 / 3) b.type = DuOCO.Bone.TAIL_MID;
        else b.type = DuOCO.Bone.TAIL_END;
        
        if (b.children.length > 0) b = b.children[0];
    }

    b.name = DuScriptUI.String.TAIL + '_' + DuScriptUI.String.TIP_BONE;
    b.type = DuOCO.Bone.TIP;

    return limb;
}

/**
 * Creates a new hair strand.
 * @param {int} [numBones=3] Number of hair bones
 * @returns {DuOCOLimb} The hair
 */
DuOCODoc.prototype.newHairStrand = function( numBones )
{
    numBones = def( numBones, 3 );

    // Unit
    var u = this.height;

    // count how many bones we need
    var num = numBones+1;

    if (num == 1) return null;

    // Create limb
    var limb = this.newLimb( DuOCO.Limb.HAIR, DuOCO.Side.NONE, DuOCO.Location.NONE );
    var b = limb.newArmature( DuScriptUI.String.HAIR, num );

    var l = 100 / numBones;

    // for each part, adjust name and type
    for (var i = 0, n = num-1; i < n; i++)
    {
        b.name = DuScriptUI.String.HAIR;
        if ( i <= (n-1) / 3) b.type = DuOCO.Bone.HAIR_ROOT;
        else if ( i <= (n-1)*2 / 3) b.type = DuOCO.Bone.HAIR_MID;
        else b.type = DuOCO.Bone.HAIR_END;

        b.x = 0;
        b.y = 150 - i*l;
        
        if (b.children.length > 0) b = b.children[0];
    }

    b.name = DuScriptUI.String.HAIR + '_' + DuScriptUI.String.TIP_BONE;
    b.type = DuOCO.Bone.TIP;
    b.x = 0;
    b.y = 50;

    return limb;
}

/**
 * Creates a new wing.
 * @param {DuOCO.Side} [side=DuOCO.Side.LEFT] The side
 * @param {Boolean} [arm=true]  Whether to create an arm / humerus
 * @param {Boolean} [forearm=true]  Whether to create a forearm
 * @param {Boolean} [hand=true]  Whether to create a hand
 * @param {int} [feathers=5]  Number of feathers
 * @param {float[]} [position] The position of the first bone of the arm.<br />
 * If omitted, computed automatically according to the current character in the doc.
 * @param {DuOCO.View} [view=DuOCO.View.TOP] The view
 * @returns {DuOCOLimb} The wing
 */
DuOCODoc.prototype.newWing = function( side, arm, forearm, hand, feathers, position, view )
{
    side = def(side, DuOCO.Side.LEFT);
    view = def(view, DuOCO.View.TOP);

    arm = def( arm, true );
    forearm = def( forearm, true );
    hand = def( hand, true );
    feathers = def( feathers, 5 );

    // Unit
    var u = this.height;

    // count how many bones we need
    var num = 1;
    if (arm) num++;
    if (forearm) num++;
    if (hand) num++;

    if (num == 1) return null;

    // Create limb
    var limb = this.newLimb( DuOCO.Limb.WING, side, DuOCO.Location.NONE );
    var b = limb.newArmature( DuScriptUI.String.WING, num );

    // side
    var s = 1;
    if ( side == DuOCO.Side.RIGHT && (view == DuOCO.View.TOP || view == DuOCO.View.BACK) ) s = -1;
    else if ( side == DuOCO.Side.LEFT && (view == DuOCO.View.BOTTOM || view == DuOCO.View.FRONT) ) s = -1;
    else if ( view == DuOCO.View.LEFT ) s = -1;

    // arm position
    var x, y;
    if ( view == DuOCO.View.TOP || view == DuOCO.View.BOTTOM )
    {
        x = s * u * -.12;
        y = u * .64;
    }
    else return limb; // not supported yet
    var ox = 0;
    var oy = 0;

    // offset
    if (typeof position !== 'undefined' )
    {
        ox = position[0] - x;
        oy = position[1] - y;
    }

    // We need to keep the parents of the feathers
    var parent1, parent2;

    // for each part, set the location
    if ( arm )
    {
        b.name = DuScriptUI.String.ARM;
        b.type = DuOCO.Bone.HUMERUS;
        b.x = x + ox;
        b.y = y + oy;

        if (!forearm && !hand)
        {
            parent1 = b;
            parent2 = b;
        }

        if (b.children.length > 0) b = b.children[0];
    }
    if (forearm)
    {
        b.name = DuScriptUI.String.FOREARM;
        b.type = DuOCO.Bone.RADIUS;
        b.x = s * u * -.22 + ox;
        b.y = u * .53 + oy;

        parent1 = b;
        if (!hand) parent2 = b;

        if (b.children.length > 0) b = b.children[0];
    }
    if (hand)
    {
        b.name = DuScriptUI.String.HAND;
        b.type = DuOCO.Bone.CARPUS;
        b.x = s * u * -.37 + ox;
        b.y = u * .64 + oy;

        parent2 = b;
        if (!forearm) parent1 = b;

        if (b.children.length > 0) b = b.children[0];
    }

    // Tip
    b.name = DuScriptUI.String.WING + '_' + DuScriptUI.String.TIP_BONE;
    b.type = DuOCO.Bone.TIP;
    b.x = s * u * -.53 + ox;
    b.y = u * .66 + oy;

    // Add Feathers
    if (feathers == 0) return limb;

    function createFeather( xr, yr, xt, yt, p )
    {
        var boneName = DuString.generateUnique(DuScriptUI.String.FEATHER, names);
        b = new DuOCOBone( boneName );
        b.type = DuOCO.Bone.FEATHER;
        b.x = s * u * xr + ox;
        b.y = u * yr + oy;

        // tip
        var boneName = DuString.generateUnique(DuScriptUI.String.FEATHER + '_' + DuScriptUI.String.TIP_BONE, names);
        var bt = new DuOCOBone( boneName );
        bt.type = DuOCO.Bone.TIP;
        bt.x = s * u * xt + ox;
        bt.y = u * yt + oy;


        bt.attached = true;

        b.children.push(bt);
        p.children.push(b);
    }

    var names = [];
    // Single one, add in the middle
    if (feathers == 1)
    {
        createFeather( -.38, .63, -.56, .28, parent1 );
        return limb;
    }

    for (var i = 0, n = feathers; i < n; i++)
    {
        if ( i < n/2)
        {
            var x = DuMath.linear( i, 0, n/2, -.54, -.38);
            var y = DuMath.linear( i, 0, n/2, .66, .63);
            var xt = DuMath.linear( i, 0, n/2, -.96, -.56);
            var yt = DuMath.linear( i, 0, n/2, .62, .28);
            createFeather( x, y, xt, yt, parent2 );
        }
        else 
        {
            var x = DuMath.linear( i, n/2, n-1, -.38, -.22);
            var y = DuMath.linear( i, n/2, n-1, .63, .51);
            var xt = DuMath.linear( i, n/2, n-1, -.56, -.08);
            var yt = DuMath.linear( i, n/2, n-1, .28, .39);
            createFeather( x, y, xt, yt, parent1 );
        }
    }

    return limb;
}

/**
 * Creates a new snake spine.
 * @param {Boolean} [head=true]  Whether to create a head
 * @param {int} [spine=5] Number of spine bones
 * @param {float[]} [position] The position of the first bone of the arm.<br />
 * If omitted, computed automatically according to the current character in the doc.
 * @returns {DuOCOLimb} The snake spine
 */
DuOCODoc.prototype.newSnakeSpine = function( head, spine, position )
{
    head = def( head, true );
    spine = def( spine, 5 );

    // Unit
    var u = this.height;

    // count how many bones we need
    var num = spine+1;

    if (num == 1) return null;

    // Create limb
    var limb = this.newLimb( DuOCO.Limb.SNAKE_SPINE, DuOCO.Side.NONE, DuOCO.Location.NONE );
    var b = limb.newArmature( DuScriptUI.String.SPINE, num );

    // hips position
    var ox = 0;
    var oy = 0;
    var x = u *.75;
    var y = u * .5;

    // offset
    if (typeof position !== 'undefined' )
    {
        ox = position[0] - x;
        oy = position[1] - y;
    }

    // for each part, set the location
    var spineLength = u*1.5 / spine;
    for (var i = 0; i < spine; i++)
    {
        b.name = DuScriptUI.String.SPINE;
        if ( i <= (spine-1) / 3) b.type = DuOCO.Bone.SNAKE_SPINE_ROOT;
        else if ( i <= (spine-1)*2 / 3) b.type = DuOCO.Bone.SNAKE_SPINE_MID;
        else b.type = DuOCO.Bone.SNAKE_SPINE_END;
        b.y = y + oy;
        b.x = x - spineLength*i - ox;
        if (b.children.length > 0) b = b.children[0];
    }

    // Tip
    b.name = DuScriptUI.String.SPINE + '_' + DuScriptUI.String.TIP_BONE;
    b.type = DuOCO.Bone.TIP;
    b.x = -u *.75;
    b.y = y + oy;

    // Head
    if (head)
    {
        var b = new DuOCOBone( DuScriptUI.String.HEAD );
        b.type = DuOCO.Bone.SKULL;
        b.x = x;
        b.y = y;

        var s = limb.armature.pop();

        limb.armature.push(b);
        b.children.push(s);

        var bt = new DuOCOBone( DuScriptUI.String.HEAD + '_' + DuScriptUI.String.TIP_BONE );
        bt.type = DuOCO.Bone.TIP;
        bt.x = x + u*.2;
        bt.y = y;
        bt.attached = true;

        b.children.push(bt);
    }

    return limb;
}

/**
 * Creates a new fin.
 * @param {int} [fishbones=5]  Number of feathers
 * @param {float[]} [position] The position of the first bone of the arm.<br />
 * If omitted, computed automatically according to the current character in the doc.
 * @param {DuOCO.View} [view=DuOCO.View.RIGHT] The view
 * @returns {DuOCOLimb} The fin
 */
DuOCODoc.prototype.newFin = function( side, fishbones, view )
{
    side = def(side, DuOCO.Side.LEFT);
    view = def(view, DuOCO.View.RIGHT);

    fishbones = def( fishbones, 5 );

    // Unit
    var u = this.height;

    // Create limb
    var limb = this.newLimb( DuOCO.Limb.FIN, side, DuOCO.Location.NONE );

    // side
    var s = 1;
    if ( side == DuOCO.Side.RIGHT && (view == DuOCO.View.TOP || view == DuOCO.View.BACK) ) s = -1;
    else if ( side == DuOCO.Side.LEFT && (view == DuOCO.View.BOTTOM || view == DuOCO.View.FRONT) ) s = -1;
    else if ( view == DuOCO.View.LEFT ) s = -1;

    // arm position
    var x = s * u * -.17;
    var y = u * .47;
    var ox = 0;
    var oy = 0;

    // offset
    if (typeof position !== 'undefined' )
    {
        ox = position[0] - x;
        oy = position[1] - y;
    }

    // Create root
    var rootBone = new DuOCOBone( DuScriptUI.String.FIN );
    rootBone.type = DuOCO.Bone.FIN;
    rootBone.x = x + ox;
    rootBone.y = y + oy;
    limb.armature.push(rootBone);
    // Tip
    var bt = new DuOCOBone( DuScriptUI.String.FIN + '_' + DuScriptUI.String.TIP_BONE );
    bt.type = DuOCO.Bone.TIP;
    bt.x = s * u * -.24 + ox;
    bt.y = u * .62 + oy;
    bt.attached = true;
    rootBone.children.push(bt);

    // Add FishBones
    if (fishbones == 0) return limb;

    var names = [];

    function createFishbone( xr, yr, xt, yt )
    {
        var boneName = DuString.generateUnique(DuScriptUI.String.FISHBONE, names);
        b = new DuOCOBone( boneName );
        b.type = DuOCO.Bone.FIN_FISHBONE;
        b.x = s * u * xr + ox;
        b.y = u * yr + oy;

        // tip
        var boneName = DuString.generateUnique(DuScriptUI.String.FISHBONE + '_' + DuScriptUI.String.TIP_BONE, names);
        var bt = new DuOCOBone( boneName );
        bt.type = DuOCO.Bone.TIP;
        bt.x = s * u * xt + ox;
        bt.y = u * yt + oy;
        bt.attached = true;

        b.children.push(bt);
        rootBone.children.push(b);
    }

    // Single one, add in the middle
    if (fishbones == 1)
    {
        createFishbone( -.22, .43, -.77, .60 );
        return limb;
    }

    for (var i = 0, n = fishbones; i < n; i++)
    {
        var x = DuMath.linear( i, 0, n-1, -.24, -.15);
        var y = DuMath.linear( i, 0, n-1, .63, .41);
        var xt = DuMath.linear( i, 0, n-1, -.82, -.17);
        var yt = DuMath.linear( i, 0, n-1, .60, .29);
        createFishbone( x, y, xt, yt );
    }

    return limb;
}

/**
 * Converts a doc coordinate in centimeters to pixel coordinates
 * @param {float[]} point The coordinate to convert
 * @returns {int[]} The coordinates in pixels relative to the comp
 */
DuOCODoc.prototype.toPixels = function( point )
{
    // First, convert to pixels
    var x = point[0]*this.pixelsPerCm;
    // minus because in 2D apps, 0 is top
    var y = -point[1]*this.pixelsPerCm;
    // We're relative to the world, add its coordinates
    x += this.world[0];
    y += this.world[1];
    return [x, y];
}

/**
 * Converts a pixel coordinate in pixels to centimeters doc coordinates
 * @param {int[]} point The coordinate to convert
 * @returns {float[]} The coordinates in centimeters relative to the doc
 */
DuOCODoc.prototype.fromPixels = function( point )
{
    var x = point[0];
    var y = point[1];
    // We're relative to the world, remove its coordinates
    x -= this.world[0];
    y -= this.world[1];
    // Convert to cm
    x /= this.pixelsPerCm;
    // Y coordinate is at bottm in OCO, top in 2D docs
    y /= -this.pixelsPerCm;
    return [x, y];
}

/**
 * Creates a new OCO Limb.
 * @class
 * @classdesc A limb contained in an OCO Doc.
 * @param {DuOCO.Limb} [limb=DuOCO.Limb.CUSTOM] A Predefined limb
 * @param {DuOCO.Side} [side=DuOCO.Side.NONE] - The side of the limb
 * @param {DuOCO.Location} [location=DuOCO.Location.NONE] - The location of the limb
 * @param {DuOCO.LimbType} [type=DuOCO.LimbType.CUSTOM] - The type of the limb
 */
function DuOCOLimb(limb, side, location, type )
{
    /**
     * The predefined limb
     * @name limb
     * @memberof DuOCOLimb
     * @type {DuOCO.Limb}
     */
    this.limb = def(limb, DuOCO.Limb.CUSTOM);
    /**
     * The type of the limb
     * @name type
     * @memberof DuOCOLimb
     * @type {DuOCO.LimbType}
     */
    this.type = def(type, DuOCO.LimbType.CUSTOM);
    /**
     * The sided of the limb
     * @name side
     * @memberof DuOCOLimb
     * @type {DuOCO.Side}
     */
    this.side = def( side, DuOCO.Side.NONE);
    /**
     * The location of the limb
     * @name location
     * @memberof DuOCOLimb
     * @type { DuOCO.Location}
     */
    this.location = def( location, DuOCO.Location.NONE);
    /**
     * The bones of the limb
     * @name location
     * @memberof DuOCOLimb
     * @type {DuOCOBone[]}
     */
    this.armature = [];
}

/**
 * Gets the boundaries of the limb
 * @returns {float[]} [left, top, right, bottom]
 */
DuOCOLimb.prototype.bounds = function( )
{
    return DuOCO.getBounds( this.armature );
}

/**
 * Creates a new chain of bones and adds it to the limb.
 * @param {string} name The name of the bones (will increment if needed)
 * @param {int} [num=2] The number of bones in the chain
 * @param {float} [length=100.0] The length in centimeters
 * @return {DuOCOBone} The root bone.
 */
DuOCOLimb.prototype.newArmature = function( name, num, length )
{
    num = def(num, 2);
    length = def(length, 100.0);
    var boneLength = length / (num-1);

    var x = -length / 2;
    var b = null;
    var root = null;
    var names = [];

    for (var i = 0; i < num; i++)
    {
        var boneName = DuString.generateUnique(name, names);
        var bone = new DuOCOBone( boneName );
        names.push(boneName);
        bone.y = 100;
        bone.x = x;

        if (b != null)
        {
            b.children.push( bone );
            bone.attached = true;
        }
        else
        {
            this.armature.push( bone );
            root = bone;
        }

        x += boneLength;
        b = bone;
    }

    return root;
}

/**
 * Creates a new OCO Bone.
 * @class
 * @classdesc A bone contained in an OCO Limb.
 * @param {string} name The name
 */
function DuOCOBone(name)
{
    /**
     * The name of the bone
     * @name name
     * @memberof DuOCOBone
     * @type {string}
     */
    this.name = name;
    /**
     * The x coordinate of the bone
     * @name x
     * @memberof DuOCOBone
     * @type {float}
     */
    this.x = 0.0;
    /**
     * The y coordinate of the bone
     * @name y
     * @memberof DuOCOBone
     * @type {float}
     */
    this.y = 0.0;
    /**
     * true if this bone is attached to its parent.
     * @name attached
     * @memberof DuOCOBone
     * @type {Boolean}
     */
    this.attached = false;
    /**
     * The child bones.
     * @name children
     * @memberof DuOCOBone
     * @type {DuOCOBone[]}
     */
    this.children = [];
    /**
     * The child limbs.
     * @name limbs
     * @memberof DuOCOBone
     * @type {DuOCOLimb[]}
     */
    this.limbs = [];
    /**
     * The type of bone.
     * @name type
     * @memberof DuOCOBone
     * @type {DuOCO.Bone}
     */
    this.type = DuOCO.Bone.CUSTOM;
}