/**
 * Methods to load and create OCO Documents and armatures
 * @namespace
 */
var DuOCO = {};

/**
 * Types of OCO armatures
 * @enum {string}
 */
DuOCO.Type = {
    /**
     * A meta-rig, used to automatically create a default armature to be used with an auto-rig.
     */
    META: 'meta',
    /**
     * An actual (rigged) character.
     */
    CHARACTER: 'character'
}

/**
 * Predefined limbs
 * @enum {string}
 */
DuOCO.Limb = {
    SPINE: 'spine',
    ARM: 'arm',
    LEG: 'leg',
    WING: 'wing',
    FIN: 'fin',
    HAIR: 'hair',
    TAIL: 'tail',
    CUSTOM: 'custom'
}

/**
 * Some bone identifierss
 * @enum {string}
 */
DuOCO.Bone = {
    CUSTOM: 'custom',
    TIP: 'tip',
    CLAVICLE: 'clavicle',
    HUMERUS: 'humerus',
    RADIUS: 'radius',
    CARPUS: 'carpus',
    FINGER: 'finger',
    HEEL: 'heel'
}

/**
 * Types of limbs
 * @enum {string}
 */
DuOCO.LimbType = {
    PLANTIGRADE: 'plantigrade',
    DIGITIGRADE: 'digitigrade',
    UNGULATE: 'ungulate',
    ARTHROPOD: 'arthropod',
    CUSTOM: 'custom'
}

/**
 * Sides for the limbs Use these with {@link DuOCO.Location} to differenciate similar limbs,<br />
 * for example, a leg can be Front-Right, Front-Left, Back-Right, Back-Left, etc.
 * @enum {string}
 */
DuOCO.Side = {
    LEFT: DuScriptUI.String.LEFT_SHORT,
    RIGHT: DuScriptUI.String.RIGHT_SHORT,
    NONE: ''
}

/**
 * Locations for the limbs. Use these with {@link DuOCO.Side} to differenciate similar limbs,<br />
 * for example, a leg can be Front-Right, Front-Left, Back-Right, Back-Left, etc.
 * @enum {string}
 */
DuOCO.Location = {
    FRONT: DuScriptUI.String.FRONT_SHORT,
    BACK: DuScriptUI.String.BACK_LOCATION_SHORT,
    TAIL: DuScriptUI.String.TAIL_SHORT,
    MIDDLE: DuScriptUI.String.MIDDLE_SHORT,
    ABOVE: DuScriptUI.String.ABOVE_SHORT,
    UNDER: DuScriptUI.String.UNDER_SHORT,
    NONE: ''
}

DuOCO.View = {
    FRONT: 0,
    LEFT: 1,
    RIGHT: 2,
    BACK: 3
}

/**
 * Gets the boundaries of an armature (a chain of bones)
 * @param {DuOCOBone[]} armature The chain of bones
 * @returns {float[]} [left, top, right, bottom]
 */
DuOCO.getBounds = function ( armature )
{
    var left = 9999;
    var right = -9999;
    var top = 9999;
    var bottom = -9999;

    for (var i = 0, n = armature.length; i < n; i++)
    {
        var b = armature[i];
        // Check current bone
        if (b.x < left) left = b.x;
        if (b.x > right) right = b.x;
        if (b.y < bottom) bottom = b.y;
        if (b.y > top) top = b.y;
        // Check children
        var childBounds = DuOCO.getBounds( b.children );
        if (childBounds[0] < left) left = childBounds[0];
        if (childBounds[1] < top) top = childBounds[1];
        if (childBounds[2] < right) right = childBounds[2];
        if (childBounds[3] < bottom) bottom = childBounds[3];
        // Check other limbs
        for ( var j = 0, nL = b.limbs.length; j < nL; j++ )
        {
            var limbBounds = b.limbs[i].bounds();
            if (limbBounds[0] < left) left = limbBounds[0];
            if (limbBounds[1] < top) top = limbBounds[1];
            if (limbBounds[2] < right) right = limbBounds[2];
            if (limbBounds[3] < bottom) bottom = limbBounds[3];
        }
    }

    return [left, top, right, bottom];
}

/**
 * Creates a new OCO Document.
 * @class
 * @classdesc An Open Cut-Out character or meta-rig document.
 * @param {string} name The name of the character or the meta rig
 */
function DuOCODoc(name)
{
    /**
     * The type of this OCO Doc
     * @name type
     * @memberof DuOCODoc
     * @type {string}
     */
    this.type = DuOCO.Type.META;
    /**
     * The name of this OCO Doc
     * @name name
     * @memberof DuOCODoc
     * @type {string}
     */
    this.name = name;
    /**
     * The height of the character. Should always be 1!
     * @name height
     * @memberof DuOCODoc
     * @type {float}
     */
    this.height = 185.0;
    /**
     * The width of the character.
     * @name width
     * @memberof DuOCODoc
     * @type {float}
     */
    this.width = 60.0,
    /**
     * The coordinates of the center of mass of the character. [X, Y].
     * @name centerOfMass
     * @memberof DuOCODoc
     * @type {float[]}
     */
    this.centerOfMass = [0.0, 107.0];
    /**
     * The limbs/ Armatures
     * @name limbs
     * @memberof DuOCOLimb
     * @type {DuOCOLimb[]}
     */
    this.limbs = [];
    this.resolution = [1920,1080];
    this.world = [960,980];
    this.pixelsPerCm = 4.22;
}

/**
 * Gets the boundaries of the doc
 * @returns {float[]} [left, top, right, bottom]
 */
DuOCODoc.prototype.bounds = function ()
{
    var left = 9999;
    var right = -9999;
    var top = 9999;
    var bottom = -9999;

    for (var i = 0, n = this.limbs.length; i < n; i++)
    {
        var limbBounds = this.limbs[i].bounds();
        if (limbBounds[0] < left) left = limbBounds[0];
        if (limbBounds[1] < top) top = limbBounds[1];
        if (limbBounds[2] < right) right = limbBounds[2];
        if (limbBounds[3] < bottom) bottom = limbBounds[3];
    }

    return [left, top, right, bottom];
}

/**
 * Updates the width and height of the character, according to the content.<br />
 * This method should be called each time a limb/bone is added/removed/edited and the bounds may change.
 */
DuOCODoc.prototype.updateSize = function()
{
    // Update doc width & height
    var bounds = this.bounds();
    // right - left
    this.width = this.bounds[2] - this.bounds[0];
    // top - bottom
    this.height = this.bounds[1] - this.bounds[3];
}

/**
 * Creates a new limb and adds it to the doc
 * @param {DuOCO.Limb} [limb=DuOCO.Limb.CUSTOM] A Predefined limb
 * @param {DuOCO.Side} [side=DuOCO.Side.NONE] - The side of the limb
 * @param {DuOCO.Location} [location=DuOCO.Location.NONE] - The location of the limb
 * @return {DuOCOLimb} The new limb
 */
DuOCODoc.prototype.newLimb = function( limb, side, location )
{
    var l = new DuOCOLimb( limb, side, location );
    this.limbs.push(l);
    return l;
}

/**
 * Creates a new arm.
 * @param {DuOCO.LimbType} [type=DuOCO.LimbType.PLANTIGRADE] The type of limb
 * @param {DuOCO.Side} [side=DuOCO.Side.LEFT] The side
 * @param {Boolean} [shoulder=false] Whether to create a shoulder
 * @param {Boolean} [arm=true]  Whether to create an arm / humerus
 * @param {Boolean} [forearm=true]  Whether to create a forearm
 * @param {Boolean} [hand=true]  Whether to create a hand
 * @param {Boolean} [claws=false]  Whether to add claws
 * @param {float[]} [position] The position of the first bone of the arm.<br />
 * If omitted, computed automatically according to the current character in the doc.
 * @param {DuOCO.Location} [location=DuOCO.Location.FRONT] The location of the limb
 * @param {DuOCO.View} [view] The view
 * @returns {DuOCOLimb} The arm
 */
DuOCODoc.prototype.newArm = function( type, side, shoulder, arm, forearm, hand, claws, position, location, view )
{
    side = def(side, DuOCO.Side.LEFT);
    type = def(type, DuOCO.LimbType.PLANTIGRADE);
    location = def(location, DuOCO.Location.FRONT);

    shoulder = def( shoulder, false );
    arm = def( arm, true );
    forearm = def( forearm, true );
    hand = def( hand, true );
    claws = def( claws, false );

    // Unit
    var u = this.height;

    // type
    var hum = type == DuOCO.LimbType.PLANTIGRADE && !claws;
    var plan = type == DuOCO.LimbType.PLANTIGRADE && claws;
    var dig = type == DuOCO.LimbType.DIGITIGRADE;
    var ung = type == DuOCO.LimbType.UNGULATE;
    var artF = type == DuOCO.LimbType.ARTHROPOD && location != DuOCO.Location.MIDDLE && location != DuOCO.Location.BACK;
    var artM = type == DuOCO.LimbType.ARTHROPOD && location == DuOCO.Location.MIDDLE;
    var artB = type == DuOCO.LimbType.ARTHROPOD && location == DuOCO.Location.BACK;
    if ( !hum && !plan && !dig && !ung && !artF && !artM && !artB ) hum = true;

    // View
    if (typeof view === 'undefined')
    {
        if (type == DuOCO.PLANTIGRADE && !claws) view = DuOCO.View.FRONT;
        else view = DuOCO.View.RIGHT;
    }

    // count how many bones we need
    var num = 1;
    if ( shoulder ) num++;
    if ( arm ) num++;
    if ( forearm ) num++;
    if ( hand ) num++;
    if ( claws ) num++;

    if (num == 1) return null;

    // Create limb
    var limb = this.newLimb( DuOCO.Limb.ARM, side, location );
    var b = limb.newArmature( DuScriptUI.String.ARM, num );

    // side
    var s = 1;
    if ( side == DuOCO.Side.RIGHT && view == DuOCO.View.FRONT ) s = -1;
    else if ( side == DuOCO.Side.LEFT && view == DuOCO.View.BACK ) s = -1;
    else if ( view == DuOCO.View.LEFT ) s = -1;  

    // shoulder position
    var x, y;
    var ox = 0;
    var oy = 0;
    if (hum)
    {
        x = s * u * .02;
        y = u * .78;
    }
    else if (plan)
    {
        x = s * u * .40;
        y = u * .92;
    }
    else if (dig)
    {
        x = s * u * .45;
        y = u * .86;
    }
    else if (ung)
    {
        x = s * u * .33;
        y = u * .80;
    }
    else if (artF)
    {
        x = s * u * .33;
        y = u * .65;
    }
    else if (artM)
    {
        x = s * u * .09;
        y = u * .50;
    }
    else if (artB)
    {
        x = s * u * -.03;
        y = u * .48;
    }

    // offset
    if (typeof position !== 'undefined' )
    {
        ox = position[0] - x;
        oy = position[1] - y;
    }

    // for each part, set the location
    if ( shoulder )
    {
        b.name = DuScriptUI.String.SHOULDER;
        b.type = DuOCO.Bone.CLAVICLE;
        b.x = s * x + ox;
        b.y = y + oy;
        if (b.children.length > 0) b = b.children[0];
    }
    if ( arm )
    {
        b.name = DuScriptUI.String.ARM;
        b.type = DuOCO.Bone.HUMERUS;
        if (hum)
        {
            b.x = s * u * .12 + ox;
            b.y = u * .77 + oy;
        }
        else if (plan)
        {
            b.x = s * u * .48 + ox;
            b.y = u*.74 + oy;
        }
        else if (dig)
        {
            b.x = s * u * .45 + ox;
            b.y = u*.66 + oy;
        }
        else if (ung)
        {
            b.x = s * u * .35 + ox;
            b.y = u*.63 + oy;
        }
        else if (artF)
        {
            b.x = s * u * .24 + ox;
            b.y = u*.45 + oy;
        }
        else if (artM)
        {
            b.x = s * u * -.01 + ox;
            b.y = u*.44 + oy;
        }
        else if (artB)
        {
            b.x = s * u * -.17 + ox;
            b.y = u*.43 + oy;
        }
        if (b.children.length > 0) b = b.children[0];
    }
    if ( forearm )
    {
        b.name = DuScriptUI.String.FOREARM;
        b.type = DuOCO.Bone.RADIUS;
        if (hum)
        {
            b.x = s * u * .15 + ox;
            b.y = u *.65 + oy;
        }
        else if (plan)
        {
            b.x = s * u * .36 + ox;
            b.y = u*.44 + oy;
        }
        else if (dig)
        {
            b.x = s * u * .21 + ox;
            b.y = u*.45 + oy;
        }
        else if (ung)
        {
            b.x = s * u * .21 + ox;
            b.y = u*.31 + oy;
        }
        else if (artF)
        {
            b.x = s * u * .55 + ox;
            b.y = u*.80 + oy;
        }
        else if (artM)
        {
            b.x = s * u * -.08 + ox;
            b.y = u*.82 + oy;
        }
        else if (artB)
        {
            b.x = s * u * -.44 + ox;
            b.y = u*.92 + oy;
        }
        if (b.children.length > 0) b = b.children[0];
    }
    if ( hand )
    {
        b.name = DuScriptUI.String.HAND;
        b.type = DuOCO.Bone.CARPUS;
        if (hum)
        {
            b.x = s * u * .12 + ox;
            b.y = u * .51 + oy;
        }
        else if (plan)
        {
            b.x = s * u * .38 + ox;
            b.y = u*.05 + oy;
        }
        else if (dig)
        {
            b.x = s * u * .45 + ox;
            b.y = u*.14 + oy;
        }
        else if (ung)
        {
            b.x = s * u * .19 + ox;
            b.y = u*.13 + oy;
        }
        else if (artF)
        {
            b.x = s * u * .77 + ox;
            b.y = u*.28 + oy;
        }
        else if (artM)
        {
            b.x = s * u * -.17 + ox;
            b.y = u*.42 + oy;
        }
        else if (artB)
        {
            b.x = s * u * -.77 + ox;
            b.y = u*.47 + oy;
        }
        if (b.children.length > 0) b = b.children[0];
    }
    if ( claws )
    {
        b.name = DuScriptUI.String.CLAWS;
        b.type = DuOCO.Bone.FINGER;
        if (plan)
        {
            b.x = s * u * .455 + ox;
            b.y = u*.035 + oy;
        }
        else if (dig)
        {
            b.x = s * u * .49 + ox;
            b.y = u*.03 + oy;
        }
        else if (ung)
        {
            b.x = s * u * .19 + ox;
            b.y = u*.07 + oy;
        }
        else if (artF)
        {
            b.x = s * u * .86 + ox;
            b.y = u*.07 + oy;
        }
        else if (artM)
        {
            b.x = s * u * -.25 + ox;
            b.y = u*.07 + oy;
        }
        else if (artB)
        {
            b.x = s * u * -.98 + ox;
            b.y = u*.07 + oy;
        }
        if (b.children.length > 0) b = b.children[0];
    }
    // Tip
    b.name = DuScriptUI.String.ARM + '_' + DuScriptUI.String.TIP_BONE;
    b.type = DuOCO.Bone.TIP;
    if (hum)
    {
        b.x = s * u * .08 + ox;
        b.y = u * .42 + oy;
    }
    else if (plan)
    {
        b.x = s * u * .585 + ox;
        b.y = 0 + oy;
    }
    else if (dig)
    {
        b.x = s * u * .59 + ox;
        b.y = u*.03 + oy;
    }
    else if (ung)
    {
        b.x = s * u * .21 + ox;
        b.y = oy;
    }
    else if (artF)
    {
        b.x = s * u * .93 + ox;
        b.y = oy;
    }
    else if (artM)
    {
        b.x = s * u * -.31 + ox;
        b.y = oy;
    }
    else if (artB)
    {
        b.x = s * u * -1.06 + ox;
        b.y = oy;
    }

    //Heel
    if (plan)
    {
        var heelBone = new DuOCOBone( DuScriptUI.String.HEEL );
        heelBone.type = DuOCO.Bone.HEEL;
        heelBone.x = s * u * .38 + ox;
        heelBone.y = 0 + oy;
        b.children.push(heelBone);
    }

    return limb;
}

/**
 * Converts a doc coordinate in centimeters to pixel coordinates
 * @param {float[]} point The coordinate to convert
 * @returns {int[]} The coordinates in pixels relative to the comp
 */
DuOCODoc.prototype.toPixels = function( point )
{
    // First, convert to pixels
    var x = point[0]*this.pixelsPerCm;
    // minus because in 2D apps, 0 is top
    var y = -point[1]*this.pixelsPerCm;
    // We're relative to the world, add its coordinates
    x += this.world[0];
    y += this.world[1];
    return [x, y];
}

/**
 * Converts a pixel coordinate in pixels to centimeters doc coordinates
 * @param {int[]} point The coordinate to convert
 * @returns {float[]} The coordinates in centimeters relative to the doc
 */
DuOCODoc.prototype.fromPixels = function( point )
{
    var x = point[0];
    var y = point[1];
    // We're relative to the world, remove its coordinates
    x -= this.world[0];
    y -= this.world[1];
    // Convert to cm
    x /= this.pixelsPerCm;
    // Y coordinate is at bottm in OCO, top in 2D docs
    y /= -this.pixelsPerCm;
    return [x, y];
}

/**
 * Creates a new OCO Limb.
 * @class
 * @classdesc A limb contained in an OCO Doc.
 * @param {DuOCO.Limb} [limb=DuOCO.Limb.CUSTOM] A Predefined limb
 * @param {DuOCO.Side} [side=DuOCO.Side.NONE] - The side of the limb
 * @param {DuOCO.Location} [location=DuOCO.Location.NONE] - The location of the limb
 */
function DuOCOLimb(limb, side, location )
{
    /**
     * The predefined limb
     * @name limb
     * @memberof DuOCOLimb
     * @type {DuOCO.Limb}
     */
    this.limb = def(limb, DuOCO.Limb.CUSTOM);
    /**
     * The type of the limb
     * @name type
     * @memberof DuOCOLimb
     * @type {DuOCO.LimbType}
     */
    this.type = DuOCO.LimbType.CUSTOM;
    /**
     * The sided of the limb
     * @name side
     * @memberof DuOCOLimb
     * @type {DuOCO.Side}
     */
    this.side = def( side, DuOCO.Side.NONE);
    /**
     * The location of the limb
     * @name location
     * @memberof DuOCOLimb
     * @type { DuOCO.Location}
     */
    this.location = def( location, DuOCO.Location.NONE);
    /**
     * The bones of the limb
     * @name location
     * @memberof DuOCOLimb
     * @type {DuOCOBone[]}
     */
    this.armature = [];
}

/**
 * Gets the boundaries of the limb
 * @returns {float[]} [left, top, right, bottom]
 */
DuOCOLimb.prototype.bounds = function( )
{
    return DuOCO.getBounds( this.armature );
}

/**
 * Creates a new chain of bones and adds it to the limb.
 * @param {string} name The name of the bones (will increment if needed)
 * @param {int} [num=2] The number of bones in the chain
 * @param {float} [length=100.0] The length in centimeters
 * @return {DuOCOBone} The root bone.
 */
DuOCOLimb.prototype.newArmature = function( name, num, length )
{
    num = def(num, 2);
    length = def(length, 100.0);
    var boneLength = length / (num-1);

    var x = -length / 2;
    var b = null;
    var root = null;
    var names = [];

    for (var i = 0; i < num; i++)
    {
        var boneName = DuString.generateUnique(name, names);
        var bone = new DuOCOBone( boneName );
        names.push(boneName);
        bone.y = 100;
        bone.x = x;

        if (b != null)
        {
            b.children.push( bone );
            bone.attached = true;
        }
        else
        {
            this.armature.push( bone );
            root = bone;
        }

        x += boneLength;
        b = bone;
    }

    return root;
}

/**
 * Creates a new OCO Bone.
 * @class
 * @classdesc A bone contained in an OCO Limb.
 * @param {string} name The name
 */
function DuOCOBone(name)
{
    /**
     * The name of the bone
     * @name name
     * @memberof DuOCOBone
     * @type {string}
     */
    this.name = name;
    /**
     * The x coordinate of the bone
     * @name x
     * @memberof DuOCOBone
     * @type {float}
     */
    this.x = 0.0;
    /**
     * The y coordinate of the bone
     * @name y
     * @memberof DuOCOBone
     * @type {float}
     */
    this.y = 0.0;
    /**
     * true if this bone is attached to its parent.
     * @name attached
     * @memberof DuOCOBone
     * @type {Boolean}
     */
    this.attached = false;
    /**
     * The child bones.
     * @name children
     * @memberof DuOCOBone
     * @type {DuOCOBone[]}
     */
    this.children = [];
    /**
     * The child limbs.
     * @name limbs
     * @memberof DuOCOBone
     * @type {DuOCOLimb[]}
     */
    this.limbs = [];
    /**
     * The type of bone.
     * @name type
     * @memberof DuOCOBone
     * @type {DuOCO.Bone}
     */
    this.type = DuOCO.Bone.CUSTOM;
}